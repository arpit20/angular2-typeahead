var ts = require('typescript');
var extend = require('xtend');
var has = require('has');
var Promise = require('native-or-bluebird');
var os_1 = require('os');
var path_1 = require('path');
var fs_1 = require('../utils/fs');
var path_2 = require('../utils/path');
var references_1 = require('../utils/references');
var config_1 = require('../utils/config');
var parse_1 = require('../utils/parse');
var typings_1 = require('../typings');
var error_1 = require('./error');
var SEPARATOR = '~';
function compile(tree, options) {
    var files = {};
    return Promise.all([
        compileDependencyTree(tree, extend(options, { browser: false, files: files })),
        compileDependencyTree(tree, extend(options, { browser: true, files: files }))
    ])
        .then(function (_a) {
        var main = _a[0], browser = _a[1];
        return {
            tree: tree,
            main: main.contents,
            browser: browser.contents,
            references: mergeReferences(main.references, browser.references, true),
            missing: mergeReferences(main.missing, browser.missing, false)
        };
    });
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = compile;
function mergeReferences(main, browser, isPaths) {
    var map = {};
    function addEntry(entry, browser) {
        var path = entry.path, raw = entry.raw, src = entry.src, name = entry.name;
        var location;
        if (isPaths) {
            location = parse_1.resolveDependency(raw, path_2.relativeTo(src, path));
        }
        else {
            location = path;
        }
        var values = map[location] || (map[location] = []);
        for (var _i = 0; _i < values.length; _i++) {
            var value = values[_i];
            if (value.name === name) {
                if (browser) {
                    value.browser = true;
                }
                else {
                    value.main = true;
                }
                return;
            }
        }
        values.push({
            name: name,
            main: !browser,
            browser: browser
        });
    }
    for (var _i = 0; _i < main.length; _i++) {
        var entry = main[_i];
        addEntry(entry, false);
    }
    for (var _a = 0; _a < browser.length; _a++) {
        var entry = browser[_a];
        addEntry(entry, true);
    }
    return map;
}
function getStringifyOptions(tree, options, parent) {
    var overrides = {};
    var isTypings = typeof tree.typings === 'string';
    var main = isTypings ? tree.typings : tree.main;
    var browser = isTypings ? tree.browserTypings : tree.browser;
    if (options.browser && browser) {
        if (typeof browser === 'string') {
            var mainDefinition = path_2.resolveFrom(tree.src, path_2.normalizeToDefinition(main));
            var browserDefinition = path_2.resolveFrom(tree.src, path_2.normalizeToDefinition(browser));
            overrides[mainDefinition] = browserDefinition;
        }
        else {
            var browserOverrides = browser;
            for (var _i = 0, _a = Object.keys(browserOverrides); _i < _a.length; _i++) {
                var key = _a[_i];
                if (!path_2.isModuleName(key)) {
                    var from = path_2.resolveFrom(tree.src, path_2.normalizeToDefinition(key));
                    var to = path_2.resolveFrom(tree.src, path_2.normalizeToDefinition(browserOverrides[key]));
                    overrides[from] = to;
                }
                else {
                    overrides[key] = browserOverrides[key];
                }
            }
        }
    }
    var imported = {};
    var referenced = {};
    var dependencies = {};
    var entry = main == null ? main : path_2.resolveFrom(tree.src, path_2.normalizeToDefinition(main));
    return extend(options, {
        tree: tree,
        entry: entry,
        isTypings: isTypings,
        overrides: overrides,
        imported: imported,
        referenced: referenced,
        dependencies: dependencies,
        parent: parent
    });
}
function compileDependencyTree(tree, options) {
    return compileDependencyPath(null, getStringifyOptions(tree, options, undefined));
}
function compileDependencyPath(path, options) {
    var tree = options.tree, entry = options.entry;
    if (tree.missing) {
        return Promise.reject(new error_1.default("Missing dependency \"" + options.name + "\", unable to compile dependency tree"));
    }
    if (path == null) {
        if (entry == null) {
            return Promise.reject(new error_1.default(("Unable to resolve entry \".d.ts\" file for \"" + options.name + "\", ") +
                'please make sure the module has a main or typings field'));
        }
        return stringifyDependencyPath(path_2.resolveFrom(tree.src, entry), options);
    }
    return stringifyDependencyPath(path_2.resolveFrom(tree.src, path), options);
}
function cachedReadFileFrom(path, options) {
    if (!has(options.files, path)) {
        options.files[path] = fs_1.readFileFrom(path);
    }
    return options.files[path];
}
function cachedStringifyOptions(name, compileOptions, options) {
    var tree = getDependency(name, options);
    if (!has(options.dependencies, name)) {
        if (tree) {
            options.dependencies[name] = getStringifyOptions(tree, compileOptions, options);
        }
        else {
            options.dependencies[name] = null;
        }
    }
    return options.dependencies[name];
}
function getDependency(name, options) {
    var tree = options.tree, overrides = options.overrides;
    if (has(options.overrides, name)) {
        return tree.dependencies[overrides[name]];
    }
    if (has(tree.dependencies, name)) {
        return tree.dependencies[name];
    }
}
function stringifyDependencyPath(path, options) {
    var definitionPath = path_2.normalizeToDefinition(path);
    var tree = options.tree, ambient = options.ambient, cwd = options.cwd, browser = options.browser, name = options.name, files = options.files, meta = options.meta, entry = options.entry;
    if (has(options.overrides, definitionPath)) {
        definitionPath = options.overrides[definitionPath];
    }
    return cachedReadFileFrom(definitionPath, options)
        .then(function (rawContents) {
        var info = ts.preProcessFile(rawContents);
        var ambientModules = info.ambientExternalModules || [];
        if (info.isLibFile) {
            return;
        }
        if (ambientModules.length && !ambient) {
            return Promise.reject(new error_1.default(("Attempted to compile \"" + options.name + "\" as a dependency, but ") +
                ("it contains ambient modules (" + ambientModules.map(JSON.stringify).join(', ') + "). ") +
                "Did you want to specify \"--ambient\" instead?"));
        }
        var importedFiles = info.importedFiles.map(function (x) { return path_2.isModuleName(x.fileName) ? x.fileName : path_2.resolveFrom(path, x.fileName); });
        var referencedFiles = info.referencedFiles.map(function (x) { return path_2.resolveFrom(path, x.fileName); });
        var missingDependencies = [];
        if (ambient) {
            Object.keys(tree.dependencies).forEach(function (x) { return importedFiles.push(x); });
        }
        var imports = importedFiles.map(function (path) {
            if (has(options.imported, path)) {
                return;
            }
            if (ambientModules.indexOf(path) > -1) {
                return;
            }
            options.imported[path] = true;
            if (path_2.isModuleName(path)) {
                var _a = getModuleNameParts(path), dependencyName = _a[0], dependencyPath = _a[1];
                var moduleName = ambient ? dependencyName : "" + name + SEPARATOR + dependencyName;
                var compileOptions = { cwd: cwd, browser: browser, files: files, name: moduleName, ambient: false, meta: meta };
                var stringifyOptions = cachedStringifyOptions(dependencyName, compileOptions, options);
                if (!stringifyOptions) {
                    if (missingDependencies.indexOf(path) === -1) {
                        missingDependencies.push(path);
                    }
                    return;
                }
                return compileDependencyPath(dependencyPath, stringifyOptions);
            }
            return stringifyDependencyPath(path, options);
        });
        return Promise.all(imports)
            .then(function (imports) {
            var stringifyOptions = extend(options, { originalPath: path });
            var stringified = stringifyFile(definitionPath, rawContents, stringifyOptions);
            var raw = tree.raw, src = tree.src;
            var references = referencedFiles.map(function (path) { return ({ name: name, path: path, raw: raw, src: src }); });
            var missing = missingDependencies.map(function (path) { return ({ name: name, path: path, raw: raw, src: src }); });
            var contents = [];
            for (var _i = 0; _i < imports.length; _i++) {
                var imported = imports[_i];
                if (imported) {
                    references = references.concat(imported.references);
                    missing = missing.concat(imported.missing);
                    contents.push(imported.contents);
                }
            }
            contents.push(stringified);
            return {
                contents: contents.join(os_1.EOL + os_1.EOL),
                references: references,
                missing: missing
            };
        });
    }, function (cause) {
        var authorPhrase = options.parent ? "The author of \"" + options.parent.name + "\" needs" : 'You need';
        var relativePath = path_2.relativeTo(tree.src, path);
        if (path === entry) {
            return Promise.reject(new error_1.default(("Unable to read typings for \"" + options.name + "\". ") +
                (authorPhrase + " to make sure the main path is correct"), cause));
        }
        return Promise.reject(new error_1.default(("Unable to read " + relativePath + " from \"" + options.name + "\". ") +
            (authorPhrase + " to check that the entry in \"" + config_1.CONFIG_FILE + "\" is ") +
            ("complete (the path \"" + relativePath + "\" appears to be missing)"), cause));
    });
}
function getModuleNameParts(moduleName) {
    var parts = moduleName.split(/[\\\/]/);
    var dependencyName = parts.shift();
    var dependencyPath = parts.length === 0 ? null : parts.join('/');
    return [dependencyName, dependencyPath];
}
function stringifyFile(path, rawContents, options) {
    var contents = rawContents.replace(references_1.REFERENCE_REGEXP, '');
    var sourceFile = ts.createSourceFile(path, contents, 2, true);
    var tree = options.tree, name = options.name, originalPath = options.originalPath;
    var source = path_2.isHttp(path) ? path : path_1.relative(options.cwd, path);
    var prefix = options.meta ? "// Compiled using " + config_1.PROJECT_NAME + "@" + typings_1.VERSION + os_1.EOL + "// Source: " + source + os_1.EOL : '';
    if (options.ambient) {
        if (sourceFile.externalModuleIndicator) {
            throw new error_1.default(("Attempted to compile " + options.name + " as an ambient ") +
                "module declaration, but it has external module indicators. Did you " +
                "want to omit \"--ambient\"?");
        }
        return "" + prefix + contents.trim();
    }
    var isES6Export = true;
    var wasDeclared = false;
    function importPath(name) {
        if (path_2.isModuleName(name)) {
            var moduleName_1 = getModuleNameParts(name)[0];
            if (options.dependencies[moduleName_1] == null) {
                return name;
            }
            return "" + options.name + SEPARATOR + name;
        }
        var relativePath = path_2.relativeTo(tree.src, path_2.resolveFrom(path, name));
        return path_2.normalizeSlashes(path_1.join(options.name, relativePath));
    }
    function replacer(node) {
        if (node.kind === 227) {
            isES6Export = !node.isExportEquals;
        }
        if (node.kind === 9 &&
            (node.parent.kind === 228 ||
                node.parent.kind === 222)) {
            return " '" + importPath(node.text) + "'";
        }
        if (node.kind === 122) {
            wasDeclared = true;
            return sourceFile.text.slice(node.getFullStart(), node.getStart());
        }
        if (node.kind === 232) {
            var path_3 = importPath(node.expression.text);
            return " require('" + path_3 + "')";
        }
    }
    function read(start, end) {
        var text = sourceFile.text.slice(start, end);
        if (start === 0) {
            return text.replace(/^\s+$/, '');
        }
        if (end == null) {
            return text.replace(/\s+$/, '');
        }
        if (wasDeclared) {
            wasDeclared = false;
            return text.replace(/^\s+/, '');
        }
        return text;
    }
    var moduleText = processTree(sourceFile, replacer, read);
    var isEntry = originalPath === options.entry;
    if (isEntry && options.isTypings) {
        return prefix + declareText(name, moduleText);
    }
    var moduleName = name + "/" + path_2.normalizeSlashes(path_2.relativeTo(tree.src, path_2.fromDefinition(path)));
    var declared = declareText(moduleName, moduleText);
    if (!isEntry) {
        return prefix + declared;
    }
    var importText = isES6Export ?
        "export * from '" + moduleName + "';" :
        "import main = require('" + moduleName + "');" + os_1.EOL + "export = main;";
    return prefix + declared + os_1.EOL + declareText(name, importText);
}
function declareText(name, text) {
    return "declare module '" + name + "' {" + os_1.EOL + text + os_1.EOL + "}";
}
function processTree(sourceFile, replacer, reader) {
    var code = '';
    var position = 0;
    function skip(node) {
        position = node.end;
    }
    function readThrough(node) {
        code += reader(position, node.pos);
        position = node.pos;
    }
    function visit(node) {
        readThrough(node);
        var replacement = replacer(node);
        if (replacement != null) {
            code += replacement;
            skip(node);
        }
        else {
            ts.forEachChild(node, visit);
        }
    }
    visit(sourceFile);
    code += reader(position);
    return code;
}
//# sourceMappingURL=compile.js.map